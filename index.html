<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My 24時間スケジュール</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom styles for color selection circles */
        .color-circle {
            width: 2rem; /* w-8 */
            height: 2rem; /* h-8 */
            border-radius: 9999px; /* rounded-full */
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease-in-out;
        }
        .color-circle.selected {
            border-color: #3B82F6; /* blue-500 */
        }

        /* Custom styles for delete button hover effect */
        .segment-group .delete-button-wrapper {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none; /* Initially not clickable */
        }
        .segment-group:hover .delete-button-wrapper {
            opacity: 1;
            pointer-events: auto; /* Make clickable on hover */
        }

        /* Basic form input styles (Tailwind's form plugin would usually handle this) */
        input[type="text"], select {
            @apply flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-background placeholder:text-gray-400 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50;
        }
        button {
            @apply inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2;
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700;
        }
        .btn-danger {
            @apply bg-red-500 text-white hover:bg-red-600;
        }
    </style>
</head>
<body class="min-h-screen bg-gray-100 flex flex-col items-center p-4">
    <header class="w-full max-w-lg mb-8 text-center">
        <h1 class="text-3xl font-bold text-blue-600 mb-2">My 24時間スケジュール</h1>
        <p class="text-lg text-gray-600">あなたの1日を可視化しましょう</p>
    </header>

    <div class="flex flex-col md:flex-row items-center md:items-start md:space-x-8 w-full max-w-4xl">
        <!-- スケジュール入力フォーム -->
        <div class="bg-white p-4 rounded-lg shadow-md w-full max-w-sm mb-4 md:mb-0">
            <h2 class="text-xl font-semibold mb-4 text-center">スケジュールを追加</h2>
            <form id="schedule-form" class="space-y-4">
                <div>
                    <label for="activityName" class="block text-sm font-medium leading-none mb-1">活動名</label>
                    <input
                        type="text"
                        id="activityName"
                        placeholder="例: 睡眠、仕事、食事"
                        required
                    />
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="startTime" class="block text-sm font-medium leading-none mb-1">開始時刻</label>
                        <select id="startTime">
                            <!-- Options will be generated by JavaScript -->
                        </select>
                    </div>
                    <div>
                        <label for="endTime" class="block text-sm font-medium leading-none mb-1">終了時刻</label>
                        <select id="endTime">
                            <!-- Options will be generated by JavaScript -->
                        </select>
                    </div>
                </div>
                <div>
                    <label for="colorPicker" class="block text-sm font-medium leading-none mb-1">色</label>
                    <div id="colorPicker" class="grid grid-cols-6 gap-2 mt-2">
                        <!-- Color circles will be generated by JavaScript -->
                    </div>
                </div>
                <p id="message" class="text-red-500 text-sm mt-2 hidden"></p>
                <button type="submit" class="w-full btn-primary">スケジュールに追加</button>
            </form>
            <button id="clearAllButton" class="w-full mt-4 btn-danger hidden">全てクリア</button>
        </div>

        <!-- 円グラフ表示エリア -->
        <div class="bg-white p-4 rounded-lg shadow-md w-full max-w-sm flex flex-col items-center justify-center">
            <h2 class="text-xl font-semibold mb-4 text-center">24時間スケジュール</h2>
            <svg id="schedule-chart" width="300" height="300" viewBox="0 0 300 300"></svg>
            <div id="activity-list" class="mt-4 w-full px-2 max-h-48 overflow-y-auto">
                <h3 class="text-md font-semibold mb-2">現在の活動:</h3>
                <ul id="current-activities-ul" class="space-y-2">
                    <!-- Activities will be listed here by JavaScript -->
                </ul>
            </div>
        </div>
    </div>

    <script>
        // DOM要素の取得
        const scheduleForm = document.getElementById('schedule-form');
        const activityNameInput = document.getElementById('activityName');
        const startTimeSelect = document.getElementById('startTime');
        const endTimeSelect = document.getElementById('endTime');
        const colorPickerContainer = document.getElementById('colorPicker');
        const messageDisplay = document.getElementById('message');
        const scheduleChart = document.getElementById('schedule-chart');
        const clearAllButton = document.getElementById('clearAllButton');
        const currentActivitiesUl = document.getElementById('current-activities-ul');

        // スケジュール活動を格納する配列
        let activities = [];

        // スケジュールセグメントに使用する色
        const colors = [
            '#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF', '#33FFF3',
            '#FFBD33', '#33FFBD', '#BD33FF', '#FF3366', '#66FF33', '#3366FF'
        ];
        let selectedColor = colors[0]; // デフォルトで最初の色を選択

        // 時刻選択肢の生成 (30分刻み)
        const timeOptions = Array.from({ length: 24 * 2 }, (_, i) => {
            const hour = Math.floor(i / 2);
            const minute = (i % 2) * 30;
            return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        });

        /**
         * "HH:MM"形式の時刻文字列を分に変換する
         * @param {string} timeString - "HH:MM"形式の時刻文字列
         * @returns {number} 00:00からの経過分数
         */
        const getMinutes = (timeString) => {
            const [hour, minute] = timeString.split(':').map(Number);
            return hour * 60 + minute;
        };

        /**
         * 分数を角度に変換する (360度スケール)
         * @param {number} minutes - 00:00からの経過分数
         * @returns {number} 角度（度）
         */
        const getAngle = (minutes) => {
            return (minutes / (24 * 60)) * 360;
        };

        /**
         * 極座標をデカルト座標に変換する
         * @param {number} centerX - 円の中心のX座標
         * @param {number} centerY - 円の中心のY座標
         * @param {number} radius - 半径
         * @param {number} angleInDegrees - 角度（度）
         * @returns {{x: number, y: number}} デカルト座標
         */
        const polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
            // SVGのY軸が下方向なので、角度を調整し、0度が上（-90度）になるように調整
            const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        };

        /**
         * SVGの円弧パスデータを作成する
         * @param {number} x - 円の中心のX座標
         * @param {number} y - 円の中心のY座標
         * @param {number} radius - 半径
         * @param {number} startAngle - 開始角度（度）
         * @param {number} endAngle - 終了角度（度）
         * @returns {string} SVGパスデータ
         */
        const describeArc = (x, y, radius, startAngle, endAngle) => {
            const start = polarToCartesian(x, y, radius, endAngle);
            const end = polarToCartesian(x, y, radius, startAngle);
            const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';

            return [
                'M', start.x, start.y,
                'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y,
                'L', x, y,
                'Z'
            ].join(' ');
        };

        /**
         * エラー/メッセージを表示する
         * @param {string} msg - 表示するメッセージ
         * @param {boolean} isError - エラーメッセージかどうか
         */
        const showMessage = (msg, isError = true) => {
            messageDisplay.textContent = msg;
            messageDisplay.classList.remove('hidden');
            messageDisplay.classList.toggle('text-red-500', isError);
            messageDisplay.classList.toggle('text-green-500', !isError);
        };

        /**
         * メッセージを非表示にする
         */
        const hideMessage = () => {
            messageDisplay.classList.add('hidden');
            messageDisplay.textContent = '';
        };

        /**
         * スケジュール活動をローカルストレージに保存する
         */
        const saveActivities = () => {
            try {
                localStorage.setItem('24h_schedule_app_activities', JSON.stringify(activities));
            } catch (error) {
                console.error("活動の保存中にエラーが発生しました:", error);
            }
        };

        /**
         * ローカルストレージからスケジュール活動を読み込む
         */
        const loadActivities = () => {
            try {
                const storedActivities = localStorage.getItem('24h_schedule_app_activities');
                if (storedActivities) {
                    activities = JSON.parse(storedActivities);
                }
            } catch (error) {
                console.error("活動の読み込み中にエラーが発生しました:", error);
                activities = []; // エラーが発生した場合は空の配列にリセット
            }
        };

        /**
         * 円グラフと活動リストをレンダリングする
         */
        const renderSchedule = () => {
            const centerX = 150;
            const centerY = 150;
            const radius = 100;

            // SVGコンテンツをクリア
            scheduleChart.innerHTML = '';
            currentActivitiesUl.innerHTML = '';

            // ベースの円を描画
            const baseCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            baseCircle.setAttribute('cx', centerX);
            baseCircle.setAttribute('cy', centerY);
            baseCircle.setAttribute('r', radius);
            baseCircle.setAttribute('fill', '#f0f0f0');
            baseCircle.setAttribute('stroke', '#ccc');
            baseCircle.setAttribute('stroke-width', '2');
            scheduleChart.appendChild(baseCircle);

            // 時刻の目盛り線とラベルを描画
            for (let i = 0; i < 24; i++) {
                const hour = i;
                // 時刻の角度を計算（各時間の開始位置）
                const angle = getAngle(i * 60);
                const start = polarToCartesian(centerX, centerY, radius, angle);
                const end = polarToCartesian(centerX, centerY, radius + 10, angle); // 線を少し外側に伸ばす

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', start.x);
                line.setAttribute('y1', start.y);
                line.setAttribute('x2', end.x);
                line.setAttribute('y2', end.y);
                line.setAttribute('stroke', '#ccc');
                line.setAttribute('stroke-width', '1');
                scheduleChart.appendChild(line);

                // 時刻ラベルの位置を計算
                const textRadius = radius + 25; // ラベルをさらに外側に配置
                const textPos = polarToCartesian(centerX, centerY, textRadius, angle); // 線の真上に配置

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', textPos.x);
                text.setAttribute('y', textPos.y);
                text.setAttribute('fill', '#555');
                text.setAttribute('font-size', '12');
                text.setAttribute('text-anchor', 'middle'); // 中央揃え
                text.setAttribute('alignment-baseline', 'middle'); // 垂直方向中央揃え
                text.textContent = `${hour}時`;
                scheduleChart.appendChild(text);
            }

            // 活動を時間順にソートして描画
            const sortedActivities = [...activities].sort((a, b) =>
                getMinutes(a.startTime) - getMinutes(b.startTime)
            );

            sortedActivities.forEach(activity => {
                const startMinutes = getMinutes(activity.startTime);
                let endMinutes = getMinutes(activity.endTime);

                // 終了時刻が00:00で開始時刻が00:00でない場合、24:00として扱う
                if (activity.endTime === '00:00' && activity.startTime !== '00:00') {
                    endMinutes = 24 * 60;
                }

                const startAngle = getAngle(startMinutes);
                const endAngle = getAngle(endMinutes);

                // ゼロ長のセグメントは描画しない
                if (startAngle === endAngle) return;

                const pathData = describeArc(centerX, centerY, radius, startAngle, endAngle);

                const segmentGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                segmentGroup.classList.add('segment-group'); // ホバー効果のためのクラス
                segmentGroup.dataset.activityId = activity.id; // 削除のためのIDを保持

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('fill', activity.color);
                path.setAttribute('stroke', 'white');
                path.setAttribute('stroke-width', '1');
                segmentGroup.appendChild(path);

                // ラベルテキストの位置を計算
                const midAngle = (startAngle + endAngle) / 2;
                const textRadius = radius * 0.6; // 中心に近い位置にテキストを配置
                const textPos = polarToCartesian(centerX, centerY, textRadius, midAngle);

                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('x', textPos.x);
                textElement.setAttribute('y', textPos.y);
                textElement.setAttribute('fill', 'white'); // ここを白色に変更しました
                textElement.setAttribute('font-size', '14'); // ここを大きく変更しました (例: 10から14へ)
                textElement.setAttribute('text-anchor', 'middle'); // 水平中央揃え
                textElement.setAttribute('alignment-baseline', 'middle'); // 垂直中央揃え
                // 活動名テキストは完全に横向きにするため、transform属性は設定しない
                textElement.textContent = activity.name;
                segmentGroup.appendChild(textElement);

                // 削除ボタン (foreignObjectを使ってHTMLボタンをSVG内に埋め込む)
                const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                foreignObject.setAttribute('x', textPos.x - 10);
                foreignObject.setAttribute('y', textPos.y - 10);
                foreignObject.setAttribute('width', '20');
                foreignObject.setAttribute('height', '20');
                foreignObject.classList.add('delete-button-wrapper');

                const deleteButton = document.createElement('button');
                deleteButton.classList.add('w-full', 'h-full', 'flex', 'items-center', 'justify-center', 'bg-black', 'bg-opacity-50', 'text-white', 'rounded-full', 'text-xs');
                deleteButton.textContent = '×';
                deleteButton.onclick = (e) => {
                    e.stopPropagation(); // 親要素のクリックイベントが発火しないようにする
                    deleteActivity(activity.id);
                };
                foreignObject.appendChild(deleteButton);
                segmentGroup.appendChild(foreignObject);

                scheduleChart.appendChild(segmentGroup);

                // アクティビティリストへの追加
                const li = document.createElement('li');
                li.classList.add('flex', 'items-center', 'justify-between', 'py-1', 'px-2', 'rounded-md', 'bg-gray-50');
                li.innerHTML = `
                    <span class="flex items-center">
                        <span class="inline-block w-3 h-3 rounded-full mr-2" style="background-color: ${activity.color};"></span>
                        <span class="text-sm">${activity.name} (${activity.startTime} - ${activity.endTime})</span>
                    </span>
                    <button data-id="${activity.id}" class="text-red-500 hover:text-red-700 text-lg leading-none p-1 rounded-full hover:bg-gray-200">
                        &times;
                    </button>
                `;
                li.querySelector('button').onclick = (e) => {
                    deleteActivity(activity.id);
                };
                currentActivitiesUl.appendChild(li);
            });

            // 「全てクリア」ボタンの表示/非表示を切り替える
            if (activities.length > 0) {
                clearAllButton.classList.remove('hidden');
            } else {
                clearAllButton.classList.add('hidden');
            }
        };

        /**
         * 新しい活動を追加する
         * @param {object} newActivity - 追加する活動オブジェクト
         */
        const addActivity = (newActivity) => {
            activities.push(newActivity);
            saveActivities();
            renderSchedule();
        };

        /**
         * 指定されたIDの活動を削除する
         * @param {number} id - 削除する活動のID
         */
        const deleteActivity = (id) => {
            activities = activities.filter(activity => activity.id !== id);
            saveActivities();
            renderSchedule();
        };

        /**
         * 全ての活動をクリアする
         */
        const clearAllActivities = () => {
            activities = [];
            saveActivities();
            renderSchedule();
            hideMessage();
        };

        // イベントリスナーの設定
        document.addEventListener('DOMContentLoaded', () => {
            // 時刻選択肢の生成
            timeOptions.forEach(time => {
                const optionStart = document.createElement('option');
                optionStart.value = time;
                optionStart.textContent = time;
                startTimeSelect.appendChild(optionStart);

                const optionEnd = document.createElement('option');
                optionEnd.value = time;
                optionEnd.textContent = time;
                endTimeSelect.appendChild(optionEnd);
            });

            // 色選択肢の生成
            colors.forEach((color, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.classList.add('color-circle');
                colorDiv.style.backgroundColor = color;
                colorDiv.dataset.color = color;
                if (index === 0) {
                    colorDiv.classList.add('selected'); // 最初の色をデフォルトで選択状態にする
                }
                colorDiv.addEventListener('click', () => {
                    document.querySelectorAll('.color-circle').forEach(div => {
                        div.classList.remove('selected');
                    });
                    colorDiv.classList.add('selected');
                    selectedColor = colorDiv.dataset.color;
                });
                colorPickerContainer.appendChild(colorDiv);
            });

            // ローカルストレージから活動を読み込み、初回レンダリング
            loadActivities();
            renderSchedule();
        });

        // フォーム送信イベント
        scheduleForm.addEventListener('submit', (e) => {
            e.preventDefault(); // デフォルトのフォーム送信を防ぐ

            hideMessage(); // メッセージをクリア

            const name = activityNameInput.value.trim();
            const startTime = startTimeSelect.value;
            const endTime = endTimeSelect.value;

            if (!name) {
                showMessage('活動名を入力してください。');
                return;
            }

            const startMinutes = getMinutes(startTime);
            let endMinutes = getMinutes(endTime);

            // 終了時刻が00:00で開始時刻が00:00でない場合、24:00（翌日の深夜）として扱う
            if (endTime === '00:00' && startTime !== '00:00') {
                endMinutes = 24 * 60;
            }

            if (startMinutes >= endMinutes) {
                showMessage('開始時刻は終了時刻より前に設定してください。');
                return;
            }

            // スケジュールの重複チェック
            const hasOverlap = activities.some(activity => {
                const existingStart = getMinutes(activity.startTime);
                let existingEnd = getMinutes(activity.endTime);
                if (activity.endTime === '00:00' && activity.startTime !== '00:00') {
                    existingEnd = 24 * 60;
                }

                // 新しい活動が既存の活動の開始または終了時間内に収まっているか、または既存の活動が新しい活動の開始または終了時間内に収まっているか
                const overlapStart = Math.max(startMinutes, existingStart);
                const overlapEnd = Math.min(endMinutes, existingEnd);

                return overlapStart < overlapEnd;
            });

            if (hasOverlap) {
                showMessage('スケジュールが重複しています。別の時間帯を選択してください。');
                return;
            }

            // 新しい活動オブジェクトを作成し、追加
            const newActivity = {
                id: Date.now(), // 一意なID
                name,
                startTime,
                endTime,
                color: selectedColor,
            };

            addActivity(newActivity);

            // フォームをリセット
            activityNameInput.value = '';
            // 次の開始時刻と終了時刻を、追加した活動の終了時刻に設定
            startTimeSelect.value = newActivity.endTime;
            endTimeSelect.value = newActivity.endTime; // 終了時刻も開始時刻と同じに設定
            
            // 色選択をリセット（最初の色に設定）
            document.querySelectorAll('.color-circle').forEach((div, index) => {
                div.classList.remove('selected');
                if (index === 0) {
                    div.classList.add('selected');
                    selectedColor = colors[0];
                }
            });
        });

        // 「全てクリア」ボタンのイベント
        clearAllButton.addEventListener('click', clearAllActivities);
    </script>
</body>
</html>
